/*PGR-GNU*****************************************************************

Function's developer:
Oslandia - Aur√©lie Bousquet - 2024
Mail: aurelie.bousquet@oslandia.com / contact@oslandia.com

------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 ********************************************************************PGR-GNU*/
BEGIN;

SELECT plan(6);

-- GRAPH: 1 <=> 11
PREPARE q1 AS
SELECT * FROM pgr_contraction(
    'SELECT id, source, target, cost, reverse_cost
    FROM edges_2
    WHERE id = 1',
    ARRAY[3]::integer[],
    max_cycles => 1,
    forbidden_vertices => ARRAY[]::bigint[],
    directed => true
);

PREPARE sol1 AS
SELECT type, id, contracted_vertices, source, target, cost, vertex_order, metric
FROM (
    VALUES
        ('v'::CHAR, 1::BIGINT, ARRAY[]::BIGINT[], -1::BIGINT, -1::BIGINT, -1::FLOAT, 1::BIGINT, -2::BIGINT),
        ('v', 11, ARRAY[]::BIGINT[], -1, -1, -1, 2, 0)
)
AS t(type, id, contracted_vertices, source, target, cost, vertex_order, metric);

SELECT set_eq('q1', 'sol1');


--GRAPH: 1 <=> 11 <=> 9
PREPARE q2 AS
SELECT * FROM pgr_contraction(
    'SELECT id, source, target, cost, reverse_cost
    FROM edges_2
    WHERE id < 3',
    ARRAY[3]::integer[],
    max_cycles => 1,
    forbidden_vertices => ARRAY[]::bigint[],
    directed => true
);

PREPARE sol2 AS
SELECT type, id, contracted_vertices, source, target, cost, vertex_order, metric
FROM (
    VALUES
        ('v'::CHAR, 1::BIGINT, ARRAY[]::BIGINT[], -1::BIGINT, -1::BIGINT, -1::FLOAT, 1::BIGINT, -2::BIGINT),
        ('v', 11, ARRAY[]::BIGINT[], -1, -1, -1, 2, -2),
        ('v', 9, ARRAY[]::BIGINT[], -1, -1, -1, 3, 0)
)
AS t(type, id, contracted_vertices, source, target, cost, vertex_order, metric);

SELECT set_eq('q2', 'sol2');


--FULL GRAPH
PREPARE q3 AS
SELECT * FROM pgr_contraction(
    'SELECT id, source, target, cost, reverse_cost
    FROM edges_2',
    ARRAY[3]::integer[],
    max_cycles => 1,
    forbidden_vertices => ARRAY[]::bigint[],
    directed => true
)
ORDER BY id;

PREPARE sol3 AS
SELECT type, id, contracted_vertices, source, target, cost, vertex_order, metric
FROM (
    VALUES
        ('e'::CHAR, -4::BIGINT, ARRAY[3]::BIGINT[], 10::BIGINT, 2::BIGINT, 5::FLOAT, -1::BIGINT, -1::BIGINT),
        ('e', -3, ARRAY[3], 2, 10, 5, -1, -1),
        ('e', -2, ARRAY[1], 2, 11, 6, -1, -1),
        ('e', -1, ARRAY[1], 11, 2, 6, -1, -1),
        ('v', 1, ARRAY[]::BIGINT[], -1, -1, -1, 3, -4),
        ('v', 2, ARRAY[]::BIGINT[], -1, -1, -1, 2, -6),
        ('v', 3, ARRAY[]::BIGINT[], -1, -1, -1, 4, -4),
        ('v', 4, ARRAY[]::BIGINT[], -1, -1, -1, 5, -4),
        ('v', 5, ARRAY[]::BIGINT[], -1, -1, -1, 6, -4),
        ('v', 6, ARRAY[]::BIGINT[], -1, -1, -1, 7, -4),
        ('v', 7, ARRAY[]::BIGINT[], -1, -1, -1, 11, 0),
        ('v', 8, ARRAY[]::BIGINT[], -1, -1, -1, 10, -2),
        ('v', 9, ARRAY[]::BIGINT[], -1, -1, -1, 1, -8),
        ('v', 10, ARRAY[]::BIGINT[], -1, -1, -1, 9, -2),
        ('v', 11, ARRAY[]::BIGINT[], -1, -1, -1, 8, -2)
)
AS t(type, id, contracted_vertices, source, target, cost, vertex_order, metric);

SELECT set_eq('q3', 'sol3');


PREPARE q4 AS
SELECT * FROM pgr_contraction(
    'SELECT id, source, target, cost, reverse_cost
    FROM edges_2',
    ARRAY[3]::integer[],
    max_cycles => 1,
    forbidden_vertices => ARRAY[3]::bigint[],
    directed => true
)
ORDER BY id;

PREPARE sol4 AS
SELECT type, id, contracted_vertices, source, target, cost, vertex_order, metric
FROM (
    VALUES
        ('e'::CHAR, -6::BIGINT, ARRAY[8,10]::BIGINT[], 7::BIGINT, 3::BIGINT, 7::FLOAT, -1::BIGINT, -1::BIGINT),
        ('e', -5, ARRAY[8,10], 3, 7, 7, -1, -1),
        ('e', -4, ARRAY[10], 8, 3, 4, -1, -1),
        ('e', -3, ARRAY[10], 3, 8, 4, -1, -1),
        ('e', -2, ARRAY[1], 2, 11, 6, -1, -1),
        ('e', -1, ARRAY[1], 11, 2, 6, -1, -1),
        ('v', 1, ARRAY[]::BIGINT[], -1, -1, -1, 3, -4),
        ('v', 2, ARRAY[]::BIGINT[], -1, -1, -1, 4, -4),
        ('v', 4, ARRAY[]::BIGINT[], -1, -1, -1, 2, -8),
        ('v', 5, ARRAY[]::BIGINT[], -1, -1, -1, 5, -4),
        ('v', 6, ARRAY[]::BIGINT[], -1, -1, -1, 6, -4),
        ('v', 7, ARRAY[]::BIGINT[], -1, -1, -1, 10, -2),
        ('v', 8, ARRAY[]::BIGINT[], -1, -1, -1, 9, -2),
        ('v', 9, ARRAY[]::BIGINT[], -1, -1, -1, 1, -8),
        ('v', 10, ARRAY[]::BIGINT[], -1, -1, -1, 8, -2),
        ('v', 11, ARRAY[]::BIGINT[], -1, -1, -1, 7, -2)
)
AS t(type, id, contracted_vertices, source, target, cost, vertex_order, metric);

SELECT set_eq('q4', 'sol4');



PREPARE q5 AS
SELECT * FROM pgr_contraction(
    'SELECT id, source, target, cost, reverse_cost
    FROM edges_2
    WHERE source = ANY(ARRAY[1, 3, 10, 11]) and target = ANY(ARRAY[1, 3, 10, 11])',
    ARRAY[3]::integer[],
    max_cycles => 1,
    forbidden_vertices => ARRAY[3,11]::bigint[],
    directed => true
)
ORDER BY id;

PREPARE sol5 AS
SELECT type, id, contracted_vertices, source, target, cost, vertex_order, metric
FROM (
    VALUES
        ('e', -2::BIGINT, ARRAY[10]::BIGINT[], 3::BIGINT, 11::BIGINT, 5::FLOAT, -1::BIGINT, -1::BIGINT),
        ('e', -1, ARRAY[10], 11, 3, 5, -1, -1),
        ('v'::CHAR, 1, ARRAY[]::BIGINT[], -1, -1, -1, 1, -4),
        ('v', 10, ARRAY[]::BIGINT[], -1, -1, -1, 2, -2)
)
AS t(type, id, contracted_vertices, source, target, cost, vertex_order, metric);

SELECT set_eq('q5', 'sol5');


PREPARE q6 AS
SELECT * FROM pgr_contraction(
    'SELECT id, source, target, cost, reverse_cost
    FROM edges_2
    WHERE source = ANY(ARRAY[1, 3, 10, 11]) and target = ANY(ARRAY[1, 3, 10, 11])',
    ARRAY[3]::integer[],
    max_cycles => 1,
    forbidden_vertices => ARRAY[1,3,10,11]::bigint[],
    directed => true
);

SELECT is_empty('q6');


SELECT finish();
ROLLBACK;
